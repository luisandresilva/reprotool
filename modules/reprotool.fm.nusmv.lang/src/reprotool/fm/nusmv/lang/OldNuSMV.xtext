grammar org.eclipselabs.nusmvtools.editor.NuSMV with org.eclipse.xtext.common.Terminals

generate nuSMV "http://editor.nusmvtools.eclipselabs.org/2.4.2"

Model hidden(WS, SL_COMMENT): (modules+=Module)*;

Module:
"MODULE" name=IDENTIFIER ("(" (params+=FormalParameter) ("," params+=FormalParameter)* ")")?
//"MODULE" ID=IDENTIFIER ("(" (params+=FormalParameter) ("," params+=FormalParameter)* ")")?
//"MODULE" ID=IDENTIFIER ("(" (params+=IDENTIFIER) ("," params+=IDENTIFIER)* ")")?
	(moduleElement+=ModuleElement)*
;

//un ModuleElement e' una sezione del modulo
ModuleElement hidden(WS, SL_COMMENT):
VariableDeclaration | IVariableDeclaration | FrozenVariableDeclaration |
DefineDeclaration | ConstantsDeclaration | AssignConstraint | TransConstraint |
InitConstraint | InvarConstraint | FairnessConstraint | CtlSpecification  |
InvarSpecification | LtlSpecification | IsaDeclaration | ComputeSpecification
;
//"compute_specification" missing

//Also the single keyword "VAR" is accepted (without anything else)
VariableDeclaration hidden(WS, SL_COMMENT):
//"VAR" (vars+=VarBody ";")+
var="VAR" (vars+=VarBody)*
;

IVariableDeclaration hidden(WS, SL_COMMENT):
"IVAR" (vars+=VarBody)+
;

FrozenVariableDeclaration  hidden(WS, SL_COMMENT):
"FROZENVAR" (vars+=VarBody)+
;

VarBody hidden(WS, SL_COMMENT):
    ID=IDENTIFIER ":" type=Type semicolon ?= ";"
;

DefineDeclaration hidden(WS, SL_COMMENT):
define="DEFINE" (defineBodies+=DefineBody)*
;

DefineBody hidden(WS, SL_COMMENT):
var=VariableIdentifier ":=" assignment=SimpleExpression semicolon ?= ";"
;

ConstantsDeclaration hidden(WS, SL_COMMENT):
"CONSTANTS" constants+=IDENTIFIER ("," constants+=IDENTIFIER)* semicolon ?= ";"
;

AssignConstraint returns AssignConstraintElement hidden(WS, SL_COMMENT): assign="ASSIGN"
	(bodies+=AssignBody)*
;

AssignBody hidden(WS, SL_COMMENT):
	VarBodyAssign
	| InitBody
	| NextBody
;

VarBodyAssign returns VarBodyAssign hidden(WS, SL_COMMENT):
var=VariableIdentifier ":=" assignment=SimpleExpression semicolon ?= ";"
;

InitBody returns AssignBodyInit hidden(WS, SL_COMMENT):
"init" "(" var=VariableIdentifier ")" ":=" initial=SimpleExpression semicolon ?= ";"
;

NextBody returns NextBody hidden(WS, SL_COMMENT):
"next" "(" var=VariableIdentifier ")" ":=" next=NextExpression semicolon ?= ";"
;

TransConstraint hidden(WS, SL_COMMENT):
"TRANS" transExpression=SimpleExpression semicolon ?= ";"?
;

InitConstraint hidden(WS, SL_COMMENT):
"INIT" initExpression=SimpleExpression semicolon ?= ";"?
;

InvarConstraint hidden(WS, SL_COMMENT):
"INVAR" invarExpression=SimpleExpression semicolon ?= ";"?
;

FairnessConstraint hidden(WS, SL_COMMENT):
FairnessExpression | JusticeExpression | CompassionExpression
;

FairnessExpression hidden(WS, SL_COMMENT):
"FAIRNESS" fairnessExpr=SimpleExpression semicolon ?= ";"?
;

JusticeExpression hidden(WS, SL_COMMENT):
"JUSTICE" justiceExpr=SimpleExpression semicolon ?= ";"?
;

CompassionExpression hidden(WS, SL_COMMENT):
"COMPASSION (" firstExpr=SimpleExpression "," secondExpr=SimpleExpression ")" semicolon ?= ";"?
;

/*CtlSpecification hidden(WS, SL_COMMENT) :
"CTLSPEC" ctlExpression=CTLExpression ";"? | 
"SPEC"  ctlExpression=CTLExpression ";"? |
"CTLSPEC NAME" name=IDENTIFIER ":="  ctlExpression=CTLExpression ";"? | 
"SPEC NAME" name=IDENTIFIER ":="  ctlExpression=CTLExpression ";"?
;*/

//It doesn't work. It doesn't get all the CTL properties. Why?
//Isn't it equivalent to the previous one?
CtlSpecification hidden(WS, SL_COMMENT) :
specKeyWord=("CTLSPEC" | "SPEC") (nameKeyWord?="NAME" name=IDENTIFIER ":=")? ctlExpression=CTLExpression semicolon?=";"?
;

InvarSpecification hidden(WS, SL_COMMENT) :
"INVARSPEC" invarSpec=NextExpression ";" |
"INVARSPEC" name=IDENTIFIER ":=" invarSpec=NextExpression semicolon?=";"?
;

IsaDeclaration hidden(WS, SL_COMMENT): "ISA" id=IDENTIFIER;

LtlSpecification hidden(WS, SL_COMMENT) :
//"LTLSPEC" ltlExpression=LTLExpression ";"? | 
//"LTLSPEC NAME" name=IDENTIFIER ":="  ltlExpression=LTLExpression ";"?
"LTLSPEC" (nameId?="NAME" name=IDENTIFIER ":=")? ltlExpression=LTLExpression semicolon ?=";"?
;

/*VariableList hidden(WS, SL_COMMENT):
	(vars+=VarBody ";")+
;*/

Type hidden(WS, SL_COMMENT): SimpleType | ModuleType;

SimpleType hidden(WS, SL_COMMENT):
	{BooleanType} "boolean"
	| {WordType} ("word" "[" wordNumber=NUMBER "]") 
	| {UnsignedWordType} ("unsigned" "word" "[" uWordNumber=NUMBER "]")
	| {SignedWordType} ("signed word" "[" signedNumber=NUMBER "]")
	| {EnumType} "{" val+=Val ("," val+=Val)* "}"
	| {IntervalType} (low = NUMBER ".." high = NUMBER)
	| {ArrayType} "array" lowerBound=NUMBER ".." upperBound=NUMBER "of" type=SimpleType
;

ModuleType hidden(WS, SL_COMMENT):
//{AsyncrProcessType} ("process" moduleName=VariableIdentifier ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?)
{AsyncrProcessType} ("process" module=[Module | IDENTIFIER] ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?)
//| {SyncrProcessType} (moduleName=VariableIdentifier ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?);
| {SyncrProcessType} (module=[Module| IDENTIFIER] ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?);

Val hidden(WS, SL_COMMENT): IDENTIFIER | NUMBER | "TRUE" | "FALSE";

NextExpression hidden(WS, SL_COMMENT): simpleExpression=SimpleExpression;

//NextExpression hidden(WS, SL_COMMENT):
//simpleExpression=SimpleExpression | "next(" simpleExpArg=SimpleExpression ")";
//next?="next("? simpleExpression=SimpleExpression next2?=")"?;

/*NextExpression hidden(WS, SL_COMMENT): 
    case=CaseNextExpression
    | var=VariableIdentifier
	| "!" notNextExpression=NextExpression
	| "next" "(" simpleExpression=SimpleExpression ")" (op=LogicBinOperator right=NextExpression)?
	| left=TerminalNextExpression (op=LogicBinOperator right=NextExpression)?
	// SetNextExpression
	| "{" setElement+=NextExpression ("," setElement+=NextExpression)* "}"	
;

TerminalNextExpression hidden(WS, SL_COMMENT):
	"(" nextExpression=NextExpression ")"
	| value=IDENTIFIER
	| value=NUMBER
	| value="TRUE"
	| value="FALSE"
	| value=WORD
;*/

/*NextExpression:
	ImpliesNextExpression;

ImpliesNextExpression returns BinaryNextExpression:
	left=IffNextExpression ({BinaryNextExpression.left=current} operator="->" right=IffNextExpression)*;

IffNextExpression returns BinaryNextExpression:
	left=OrNextExpression ({BinaryNextExpression.left=current} operator="<->" right = OrNextExpression)*;

OrNextExpression returns BinaryNextExpression:
	left=AndNextExpression ({BinaryNextExpression.left=current} operator=('|'|'xor'|'xnor') right = AndNextExpression)*;

AndNextExpression returns BinaryNextExpression:
	left=ComparisonNextExpression ({BinaryNextExpression.left = current} operator='&' right=ComparisonNextExpression)*;

ComparisonNextExpression returns BinaryNextExpression:
	left=InNextExpression ({BinaryNextExpression.left = current} operator=('='|'!='|'<'|'>'|'<='|'>=') right=InNextExpression)*;

InNextExpression returns BinaryNextExpression:
	left=UnionNextExpression ({BinaryNextExpression.left = current}  operator="in" right=UnionNextExpression)*;

UnionNextExpression returns BinaryNextExpression:
	left=RightShiftNext ({BinaryNextExpression.left = current}  operator="union" right=RightShiftNext)*;

RightShiftNext returns BinaryNextExpression:
	left=LeftShiftNext ({BinaryNextExpression.left = current}  operator=">>" right=LeftShiftNext)*;

LeftShiftNext returns BinaryNextExpression:
	left=MinusNext ({BinaryNextExpression.left = current}  operator="<<" right=MinusNext)*;

MinusNext returns BinaryNextExpression:
	left=Plus ({BinaryNextExpression.left = current}  operator="-" right=PlusNext)*;

PlusNext returns BinaryNextExpression:
	left=MultNext ({BinaryNextExpression.left = current}  operator="+" right=MultNext)*;

MultNext returns BinaryNextExpression:
	left=ModNext ({BinaryNextExpression.left = current}  operator="*" right=ModNext)*;

ModNext returns BinaryNextExpression:
	left=DivNext ({BinaryNextExpression.left = current}  operator="mod" right=DivNext)*;

DivNext returns BinaryNextExpression:
	left=TerminalNextExpression ({BinaryNextExpression.left = current} operator="/" right=NextExpression)?;
	
TerminalNextExpression hidden(WS, SL_COMMENT):
    //{ParsNextExpression} next?="next" "(" parsNextExpression=NextExpression ")"
    {ParsNextExpression} "(" parsNextExpression=NextExpression ")"
   | {UnaryNextExpression} (operator=('!' | '-' | '+') nextExpression=NextExpression)
    | CaseNextExpression
    | {ValueNextExpression} value = VariableIdentifier
	| {ValueNextExpression} value = IDENTIFIER
	| {ValueNextExpression} value = NUMBER
	| {ValueNextExpression} value = "TRUE"
	| {ValueNextExpression} value = "FALSE"
	| {SetNextExpression} "{" setElement+=NextExpression ("," setElement+=NextExpression)* "}"
	| {WordNextExpression} value=WORD
	//| {NextNextExpression} "next(" argNextExpression=NextExpression ")"
	//| {SimpleExpressionInNext} simpleExpression=SimpleExpression
;

CaseNextExpression hidden(WS, SL_COMMENT):
"case"
	//(branches+=(case=NextExpression ":" assignment=NextExpression ";"))+
	(branches+=CaseAssignementNextExpression)+
"esac"
;

CaseAssignementNextExpression hidden(WS, SL_COMMENT):
case=NextExpression ":" assignment=NextExpression ";"
;
*/

/*SimpleExpression hidden(WS, SL_COMMENT): 
	 left=TerminalSimpleExpression (op=LogicBinOperator right=SimpleExpression)?
	 | opUnary=("!" | "-" | "+") simpleExpression=SimpleExpression
	 | "{" setElement+=SimpleExpression ("," setElement+=SimpleExpression)* "}" 
;

TerminalSimpleExpression hidden(WS, SL_COMMENT):
    "(" simpleExpression=SimpleExpression ")" 
    | case=CaseSimpleExpression
    | value=VariableIdentifier
	| value=IDENTIFIER
	| value=NUMBER
	| value="TRUE"
	| value="FALSE"
	| value=WORD
;*/

SimpleExpression:
	//ImpliesExpression;
	LTLbinExpression;

LTLbinExpression returns SimpleExpression:
	ImpliesExpression ({BinaryExpression.left = current} operator=("U" | "V" | "S" | "T") right=ImpliesExpression)*;

ImpliesExpression returns SimpleExpression:
	IffExpression ({BinaryExpression.left=current} operator="->" right=IffExpression)*;

IffExpression returns SimpleExpression:
	//left=IfThenElseExpression ({BinaryExpression.left=current} operator="<->" right = IfThenElseExpression)*;
	OrExpression ({BinaryExpression.left=current} operator="<->" right = OrExpression)*;

//IfThenElseExpression returns TernaryExpression:
//	cond=OrExpression "?" then=OrExpression ":" else=OrExpression;
//fine PA
OrExpression returns SimpleExpression:
	AndExpression ({BinaryExpression.left=current} operator=('|'|'xor'|'xnor') right = AndExpression)*;
	//left=AndExpression (operator=('|'|'xor'|'xnor') right = AndExpression)?;

AndExpression returns SimpleExpression:
	ComparisonExpression ({BinaryExpression.left = current} operator='&' right=ComparisonExpression)*;
	//left=ComparisonExpression (operator='&' right=ComparisonExpression)?;

ComparisonExpression returns SimpleExpression:
	//first=ATOM (operator=('='|'!='|'<'|'>'|'<='|'>=') second=ATOM)?;
	//left=ATOM ({BinaryExpression.left = current} operator='&' right=BasicExpression)*;
	InExpression ({BinaryExpression.left = current} operator=('='|'!='|'<'|'>'|'<='|'>=') right=InExpression)*;

//ComparisonExpression returns BinaryExpression:
//	InExpression ({BinaryExpression.left = current} operator=('='|'!='|'<'|'>'|'<='|'>=') right=NotExpression)*;
InExpression returns SimpleExpression:
	UnionExpression ({BinaryExpression.left = current} operator="in" right=UnionExpression)*;

UnionExpression returns SimpleExpression:
	RightShift ({BinaryExpression.left = current} operator="union" right=RightShift)*;

RightShift returns SimpleExpression:
	LeftShift ({BinaryExpression.left = current} operator=">>" right=LeftShift)*;

LeftShift returns SimpleExpression:
	Minus ({BinaryExpression.left = current} operator="<<" right=Minus)*;

Minus returns SimpleExpression:
	Plus ({BinaryExpression.left = current} operator="-" right=Plus)*;

Plus returns SimpleExpression:
	Mult ({BinaryExpression.left = current} operator="+" right=Mult)*;

Mult returns SimpleExpression:
	Mod ({BinaryExpression.left = current} operator="*" right=Mod)*;

Mod returns SimpleExpression:
	WordConcatenation ({BinaryExpression.left = current} operator="mod" right=WordConcatenation)*;

WordConcatenation returns SimpleExpression:
	//left=LTLbinExpression ({BinaryExpression.left = current} operator="::" right=LTLbinExpression)*;
	Div ({BinaryExpression.left = current} operator="::" right=Div)*;


Div returns SimpleExpression:
	NotOrTerminalSimpleExpression ({BinaryExpression.left=current} operator='/' right=NotOrTerminalSimpleExpression)*;
	//TerminalSimpleExpression ({Div.left=current} op='/' right=SimpleExpression)*;
	//first=TerminalSimpleExpression ( operator="/" second=SimpleExpression)?;

NotOrTerminalSimpleExpression returns SimpleExpression:
	{Not} '!' exp=TerminalSimpleExpression | TerminalSimpleExpression; 

TerminalSimpleExpression returns SimpleExpression hidden(WS, SL_COMMENT):
	{ParsExpression} isNext?="next"? "(" simpleExpression=SimpleExpression ")"
    //| {UnaryExpression} (operator=('!' | '-' | '+' | 'EG' | 'EX' | 'EF' | 'AG' | 'AX' | 'AF' | 'X' | 'G' | 'F' | 'Y' | 'Z' | 'H' | 'O') simpleExpression=SimpleExpression)
    | {UnaryExpression} (operator=('-' | '+' | 'EG' | 'EX' | 'EF' | 'AG' | 'AX' | 'AF' | 'X' | 'G' | 'F' | 'Y' | 'Z' | 'H' | 'O') simpleExpression=SimpleExpression)
    | CaseSimpleExpression
    //| {ParamExpression} param = [FormalParameter | IDENTIFIER]//sbagliato
    | {ValueExpression} value = VariableIdentifier
	| {ValueExpression} value = IDENTIFIER
	| {ValueExpression} value = NUMBER
	| {ValueExpression} value = "TRUE"
	| {ValueExpression} value = "FALSE"
	| {ValueExpression} value = "self"
	//| {ValueExpression} value = "running"
	| {SetExpression} "{" setElement+=SimpleExpression ("," setElement+=SimpleExpression)* "}"
	//| {ConstantExpression} (constant = Constant)
	//| {WordConstant} ("0" us=("u" | "s")? base=("b" | "B" | "o" | "O" | "d" | "D" | "h" | "H") num=(NUMBER)? "_" val=WordValue)
	| {WordExpression} value=WORD
	| {IntervalExpression} lowerBound =NUMBER ".." upperBound=NUMBER
	//| {UntilCTLexpression} ea=("E" | "A") "[" first =SimpleExpression "U" second=SimpleExpression "]"
	| {UntilCTLexpression} ea=("E" | "A") "[" arg=LTLbinExpression "]"
	| {UnaryFunctionExpression} function=("word1" | "boo1") "(" arg=SimpleExpression ")"
;

FormalParameter: ID=IDENTIFIER;

CaseSimpleExpression hidden(WS, SL_COMMENT):
"case"
	(branches+=CaseSimpleAssignementExpression)+
"esac"
;

CaseSimpleAssignementExpression hidden(WS, SL_COMMENT):
	case=SimpleExpression ":" assignment=SimpleExpression ";"
;

/*SpecDeclaration hidden(WS, SL_COMMENT) : "SPEC"
    specExpression=SpecExpression ";"
;

SpecExpression hidden(WS, SL_COMMENT) : CTLExpression;*/

/*CTLExpression hidden(WS, SL_COMMENT) :
    //{CTLSimpleExpression} simpleExpression=SimpleExpression
    //| {CTLLogicalNot} "!" ctlExpression=CTLExpression
    //|
    {OpCTL}left=TerminalCTLExpression ({CTLOperation.left=current} op=CTLBinOperator right=CTLExpression)? 
    | {CTLExistsGlobally} "EG" ctlExpression=CTLExpression
    | {CTLExistsNextState} "EX" ctlExpression=CTLExpression
    | {CTLExistsFinally} "EF" ctlExpression=CTLExpression
    | {CTLForallGlobally} "AG" ctlExpression=CTLExpression
    | {CTLForallNextState} "AX" ctlExpression=CTLExpression
    | {CTLForallFinally} "AF" ctlExpression=CTLExpression
;

TerminalCTLExpression hidden(WS, SL_COMMENT):
	{CTLSimpleExpression} simpleExpression=SimpleExpression
    | {CTLLogicalNot} "!" ctlExpression=CTLExpression
    //| {CTLPars} "(" ctlParsExpression=CTLExpression ")"
    | value=IDENTIFIER
    | value=NUMBER
    | value="TRUE"
    | value="FALSE"
    | value=WORD
;*/

CTLExpression hidden(WS, SL_COMMENT): simpleExpression=SimpleExpression;
LTLExpression hidden(WS, SL_COMMENT): simpleExpression=SimpleExpression;

RangeExpression: lower = NUMBER ".." upper = NUMBER;

RTCTLExpression hidden(WS, SL_COMMENT):
{SingleRTCTLExpression} ctlExpression=CTLExpression |
{UnaryRTCTLExpression } unary=("EBF" | "ABF" | "EBG" | "ABG")  range=RangeExpression rctl=RTCTLExpression
;

ComputeSpecification:
"COMPUTE" minMax=("MIN" | "MAX") "[" first=RTCTLExpression "," second=RTCTLExpression "]";

/*CTLExpression hidden(WS, SL_COMMENT) :
    //{CTLSimpleExpression} simpleExpression=[SimpleExpression]
    {OpCTL}left=TerminalCTLExpression ({OpCTL.left=current} op=CTLBinOperator right=CTLExpression)? 
    | {UnaryCTLExpression} (op=("EG" | "EX"| "EF"| "AG" | "AX" | "AF") ctlExpression=CTLExpression)
;

TerminalCTLExpression hidden(WS, SL_COMMENT):
	{CTLSimpleExpression} simpleExpression=[SimpleExpression]
	| {CTLLogicalNot} "!" ctlNotExpression=CTLExpression
    | {CTLPars} "(" ctlParsExpression=CTLExpression ")"
    | value=IDENTIFIER
    | value=NUMBER
    | value="TRUE"
    | value="FALSE"
    | value=WORD
;*/

//CTLBinOperator hidden(WS, SL_COMMENT): '&' 
//    | '|' | 'xor' | '->' | '<->'
//;


// ===============================

//LogicBinOperator hidden(WS, SL_COMMENT): '&' 
//	| '|' | 'xor' | 'xnor' | '->' | '<->' | '=' | '!=' | '<' | '>' | '<=' | '>=' | '+' | '-' | '*' | '/' | 'mod' | 'in' | 'union'
//;

//se si mettono le costanti non mi riconosce piu' i numeri
/*Constant hidden(WS, SL_COMMENT):
BooleanConstant | SymbolicConstant | IntegerConstant | WordConstant | RangeConstant;

BooleanConstant hidden(WS, SL_COMMENT): value=("TRUE" | "FALSE" | "1" | "0");
SymbolicConstant hidden(WS, SL_COMMENT): value=IDENTIFIER;
IntegerConstant hidden(WS, SL_COMMENT): value=NUMBER;
WordConstant hidden(WS, SL_COMMENT): "0" us=("u" | "s")? base=("b" | "B" | "o" | "O" | "d" | "D" | "h" | "H") (number=NUMBER)? "_" value=WordValue;
RangeConstant hidden(WS, SL_COMMENT): lowerBound = NUMBER ".." upperBound=NUMBER;

WordValue:
HexDigit ('_' | HexDigit)*;

terminal HexDigit:
('0'.. '9' | 'a' .. 'f' | 'A' .. 'F');*/

//DefineIdentifier hidden(WS, SL_COMMENT): ComplexIdentifier;
//VariableIdentifier hidden(WS, SL_COMMENT): ComplexIdentifier;


/*VariableIdentifier hidden(WS, SL_COMMENT): TerminalVariableIdentifier "[" NUMBER "]" |
TerminalVariableIdentifier "[" NUMBER "]" "[" NUMBER "]" 
| TerminalVariableIdentifier "[" NUMBER "]" "[" NUMBER "]"  "[" NUMBER "]" 
	| TerminalVariableIdentifier ("." VariableIdentifier)?
	| TerminalVariableIdentifier "[" NUMBER ":" NUMBER "]"
;

TerminalVariableIdentifier hidden(WS, SL_COMMENT): IDENTIFIER
;*/


VariableIdentifier hidden(WS, SL_COMMENT):
//TerminalVariableIdentifier "[" TerminalVariableIdentifier "]"
//TerminalVariableIdentifier ("[" NUMBER | TerminalVariableIdentifier "]")*
/*TerminalVariableIdentifier "[" NUMBER "]" |
TerminalVariableIdentifier "[" NUMBER "]" "[" NUMBER "]" 
| TerminalVariableIdentifier "[" NUMBER "]" "[" NUMBER "]"  "[" NUMBER "]"*/
//TerminalVariableIdentifier ("[" NUMBER | VariableIdentifier"]")*
 TerminalVariableIdentifier ("." VariableIdentifier)*
| TerminalVariableIdentifier ("[" (NUMBER | TerminalVariableIdentifier) "]")+
| TerminalVariableIdentifier "[" NUMBER ":" NUMBER"]"
//| TerminalVariableIdentifier "[" TerminalVariableIdentifier "]"
;

TerminalVariableIdentifier hidden(WS, SL_COMMENT): IDENTIFIER
;

//ComplexIdentifier hidden(WS, SL_COMMENT):
/*idValue=IDENTIFIER
| (subComplex=ComplexIdentifier '.' subId=IDENTIFIER)
| (complexSimple=ComplexIdentifier '[' simple=SimpleExpression ']')
| (selfValue='self')*/
//idValue=(IDENTIFIER | 'self') ('.' afterPoint = ComplexIdentifier)?
//;

//NUMBER hidden(WS, SL_COMMENT): INT;
terminal NUMBER: '-'? ('0'..'9')*;

terminal SL_COMMENT : '--' !('\n'|'\r')* ('\r'? '\n')? ;

terminal WORD : '0' ('u'|'s')? ('b'|'B'|'o'|'O'|'_'|'d'|'D'|'h'|'H') NUMBER? '_' ('a'..'f' | 'A.'.'F' | '0'..'9')('a'..'f' | 'A.'.'F' | '0'..'9' | '_')*;

terminal IDENTIFIER : ('A'..'Z'|'a'..'z'|'_') ('A'..'Z'|'a'..'z'|'_'|'0'..'9'|'$'|'#'|'-'|'.')*;
